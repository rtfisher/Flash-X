
[RK3]
definition =
 !RK3 quantities
  !Stage 1 coefficients
  ! U* = C1 * U0 + C2 * U* + C3 * dt*L(U*)
  ! U1 =  1 * U0           +  1 * dt*L(U0)
  !Stage 2 coefficients
  ! U* =  C1 * U0 +  C2 * U* +  C3 * dt*L(U*)
  ! U2 = 3/4 * U0 + 1/4 * U1 + 1/4 * dt*L(U1)
  !Stage 3 coefficients
  ! U* =  C1 * U0 +  C2 * U* +  C3 * dt*L(U*)
  ! U3 = 1/3 * U0 + 2/3 * U2 + 2/3 * dt*L(U2)
  !(remember FORTRAN is column major)
  coeff_array = reshape((/1.,0.75,onethird,0.,0.25,twothirds,1.,0.25,twothirds/),(/3,3/))
  last_stage = 3 
  !Array containing number of guard cells on each side for
  !the telescoping update.
  limits_array = (/2*NSTENCIL, NSTENCIL, 0/)
  !Weights that scale the fluxes as they are added into the buffers.
  !Here weights is
  the same as coeff used in Github pseudocode.
  weights = (/onesixth, onesixth, twothirds/)

[RK2]
definition =
  !RK2 quantities
  ! Stage 1 coefficients
  ! U* = C1 * U0 + C2 * U* + C3 * dt*L(U*)
  ! U1 =  1 * U0           +  1 * dt*L(U0)
  ! Stage 2 coefficients
  ! Now update solution based on conservative fluxes
  ! U* =  C1 * U0 +  C2 * U* +  C3 * dt*L(U*)
  ! U2 = 1/2 * U0 + 1/2 * U1 + 1/2 * dt*L(U1)
  coeff_array = reshape((/1.,0.5,0.,0.,0.5,0.,1.,0.5,0./),(/3,3/))
  last_stage = 2
  limits_array = (/NSTENCIL, 0, 0/)
  weights = (/0.5,0.5,0./)



[hy_rk_scheme]
definition =
 #ifdef HY_RK3
    @M RK3
 #else
    @M RK2
 #endif

[geom_1d_alloc]
line_indents=3,3,3,3,3,3,3,3,3,3
definition=
    allocate(hy_farea(xLoGC:xHiGC,yLoGC:yHiGC,zLoGC:zHiGC))
    call Grid_getCellFaceAreas(IAXIS,level,loGC,hiGC,hy_farea)
    allocate(hy_cvol(xLoGC:xHiGC,yLoGC:yHiGC,zLoGC:zHiGC))
    call Grid_getCellVolumes(level,loGC,hiGC,hy_cvol)
    allocate(hy_xCenter(xLoGC:xHiGC))
    call Grid_getCellCoords(IAXIS, CENTER, level, loGC, hiGC, hy_xCenter)
    allocate(hy_xLeft(xLoGC:xHiGC))
    call Grid_getCellCoords(IAXIS, LEFT_EDGE, level, loGC, hiGC, hy_xLeft)
    allocate(hy_xRight(xLoGC:xHiGC))
    call Grid_getCellCoords(IAXIS, RIGHT_EDGE, level, loGC, hiGC, hy_xRight) 

[geom_1d_dealloc]
line_indents=3,3,3,3,3
definition=
      deallocate(hy_xCenter)
      deallocate(hy_xLeft)
      deallocate(hy_xRight)
      deallocate(hy_farea)
      deallocate(hy_cvol)
  


[hy_geomSp_alloc]
definition=
 if (hy_geometry /= CARTESIAN) then
    @M geom_1d_alloc
 endif


[hy_geomSp_dealloc]
definition=
  if (hy_geometry /= CARTESIAN) then
     @M geom_1d_dealloc
  end if


[hy_geomSpall_alloc]
line_indents=0,0,3,3,3,3,0
definition=
 if (hy_geometry /= CARTESIAN) then
    @M geom_1d_alloc
    allocate(hy_yCenter(yLoGC:yHiGC))
    call Grid_getCellCoords(JAXIS, CENTER, level, loGC, hiGC, hy_yCenter)
    allocate(hy_zCenter(zLoGC:zHiGC))
    call Grid_getCellCoords(KAXIS, CENTER, level, loGC, hiGC, hy_zCenter)
 endif

[hy_geomSpall_dealloc]
line_indents=0,0,3,3,0
definition=
  if (hy_geometry /= CARTESIAN) then
     @M geom_1d_dealloc
      deallocate(hy_yCenter)
      deallocate(hy_zCenter)
  end if


[calcDivb]
line_indents=0,2,12,0,12,14,12,14,0,12,14,0,0,12,2,0
definition =
 #ifdef SPARK_GLM
 @M loop_3d(blkLimits)
           divB = 0.0
 #if NDIM>1
           divB = (Uin(MAGX_VAR,i+1,j,k) - Uin(MAGX_VAR,i-1,j,k))&
                *0.5/deltas(IAXIS)
           divB = divB + (Uin(MAGY_VAR,i,j+1,k) - Uin(MAGY_VAR,i,j-1,k))&
                *0.5/deltas(JAXIS)
 #if NDIM==3
           divB = divB + (Uin(MAGZ_VAR,i,j,k+1) - Uin(MAGZ_VAR,i,j,k-1))&
                *0.5/deltas(KAXIS)
 #endif
 #endif
           Uin(DIVB_VAR,i,j,k) = divB
  @M loop_end_3d
 #endif

[setLims]
definition =
  limits = blkLimits
  limits(LOW ,IAXIS) = limits(LOW ,IAXIS) - ngoff
  limits(HIGH,IAXIS) = limits(HIGH,IAXIS) + ngoff
 #if NDIM > 1
  limits(LOW ,JAXIS) = limits(LOW ,JAXIS) - ngoff
  limits(HIGH,JAXIS) = limits(HIGH,JAXIS) + ngoff
 #if NDIM == 3
  limits(LOW ,KAXIS) = limits(LOW ,KAXIS) - ngoff
  limits(HIGH,KAXIS) = limits(HIGH,KAXIS) + ngoff
 #endif /* NDIM == 3 */
 #endif /* NDIM > 1 */



[addFluxes]
definition =
 if (hy_fluxCorrect) then
  if(addFlux_array(stage))then
    hy_fluxBufX = hy_fluxBufX+weights(stage)*hy_flx(:,@M bounds_3d_plus(blkLimits,1,0,0)) 
    if (NDIM > 1) &   
      hy_fluxBufY = hy_fluxBufY+weights(stage)*hy_fly(:,@M bounds_3d_plus(blkLimits,0,1,0) )
    if (NDIM > 2) &
      hy_fluxBufZ = hy_fluxBufZ+weights(stage)*hy_flz(:, @M bounds_3d_plus(blkLimits,0,0,1))
  else
    hy_fluxBufX = weights(stage)*hy_flx(:, @M bounds_3d_plus(blkLimits,1,0,0))
    if (NDIM > 1) &   
      hy_fluxBufY = weights(stage)*hy_fly(:, @M bounds_3d_plus(blkLimits,0,1,0))
    if (NDIM > 2) &
      hy_fluxBufZ = weights(stage)*hy_flz(:,@M bounds_3d_plus(blkLimits,0,0,1))
  endif
 endif



[setSnake]
args=ix1,ix2,ix3
definition =
            hy_snake(HY_DENS,@M hy_isn) = hy_starState(DENS_VAR,ix1,ix2,ix3)
            hy_snake(HY_VELX,@M hy_isn) = hy_starState(VELX_VAR,ix1,ix2,ix3)
            hy_snake(HY_VELY,@M hy_isn) = hy_starState(VELY_VAR,ix1,ix2,ix3)
            hy_snake(HY_VELZ,@M hy_isn) = hy_starState(VELZ_VAR,ix1,ix2,ix3)
            hy_snake(HY_PRES,@M hy_isn) = hy_starState(PRES_VAR,ix1,ix2,ix3)
            hy_snake(HY_GAMC,@M hy_isn) = hy_starState(GAMC_VAR,ix1,ix2,ix3)
            hy_snake(HY_RHOE,@M hy_isn) = hy_starState(DENS_VAR,ix1,ix2,ix3)*hy_starState(EINT_VAR,ix1,ix2,ix3)
 #ifdef SPARK_GLM
            hy_snake(HY_MAGX,@M hy_isn) = hy_starState(MAGX_VAR,ix1,ix2,ix3)
            hy_snake(HY_MAGY,@M hy_isn) = hy_starState(MAGY_VAR,ix1,ix2,ix3)
            hy_snake(HY_MAGZ,@M hy_isn) = hy_starState(MAGZ_VAR,ix1,ix2,ix3)
            hy_snake(HY_PSIB,@M hy_isn) = hy_starState(PSIB_VAR,ix1,ix2,ix3)
 #endif
 #if NSPECIES+NMASS_SCALARS>0
            do n=SPECIES_BEGIN, MASS_SCALARS_END
               hy_snake(HY_NUM_VARS+1+n-SPECIES_BEGIN,@M hy_isn)    = hy_starState(n,ix1,ix2,ix3)
            enddo
 #endif
 #ifdef GRAVITY
 #ifdef GPOT_VAR
            hy_grv(@M hy_isn) = hy_starState(GPOT_VAR,ix1,ix2,ix3)
 #else
            hy_grv(@M hy_isn) = hy_grav(IAXIS,ix1,ix2,ix3)
 #endif
 #endif
 #ifdef SHOK_VAR
            hy_shck(@M hy_isn) = hy_starState(SHOK_VAR,ix1,ix2,ix3)
 #else
            hy_shck(@M hy_isn) = 0.0
 #endif
            hy_flat(@M hy_isn) = hy_flat3d(ix1,ix2,ix3)


[weno5_coeffs]
definition =
  !! Set WENO5 coefficients once and for all
  !u_{1,i+1/2}= 2/6*u_{i-2} -7/6*u_{i-1} +11/6*u_{i}
  real, dimension(3), parameter :: coeff1p1(1:3) = (/ 2./6., -7./6., 11./6./)
  !u_{2,i+1/2}=-1/6*u_{i-2} +5/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3), parameter :: coeff1p2(1:3) = (/-1./6.,  5./6.,  2./6./)
  !u_{3,i+1/2}= 2/6*u_{i-2} +5/6*u_{i-1} - 1/6*u_{i}
  real, dimension(3), parameter :: coeff1p3(1:3) = (/ 2./6.,  5./6., -1./6./)
  !(gamma1,gamma2,gamma3)
  real, dimension(3), parameter :: coeff2p(1:3)   = (/0.1, 0.6, 0.3/)
  !u_{1,i-1/2}=-1/6*u_{i-2} +5/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3), parameter :: coeff1m1(1:3) = (/-1./6.,  5./6.,  2./6./)
  !u_{2,i-1/2}= 2/6*u_{i-2} +5/6*u_{i-1} - 1/6*u_{i}
  real, dimension(3), parameter :: coeff1m2(1:3) = (/ 2./6.,  5./6., -1./6./)
  !u_{3,i-1/2}=11/6*u_{i-2} -7/6*u_{i-1} + 2/6*u_{i}
  real, dimension(3), parameter :: coeff1m3(1:3) = (/ 11./6.,-7./6.,  2./6./)
  !(gamma1,gamma2,gamma3)
  real, dimension(3), parameter :: coeff2m(1:3)   = (/0.3, 0.6, 0.1/)

[hy_ensurePhysicalState]
args = state
definition =
    state(HY_DENS @M hy_i123) = max(hy_smalldens, state(HY_DENS @M hy_i123))
    state(HY_PRES @M hy_i123) = max(hy_smallpres, state(HY_PRES @M hy_i123))
 #if NSPECIES>0
    ! Limit and renormalize the species.
    spc => state(HY_NUM_VARS+1:HY_NUM_VARS+NSPECIES @M hy_i123)
    do s = 1, NSPECIES
       spc(s) = max(hy_smallX,min(1.0,spc(s)))
    end do
    spcSumInv = 1./sum(spc(1:NSPECIES))
    spc = spc*spcSumInv
 #endif


[hy_mscalarFluxes]
args=flux,XL,XR
definition =
 #if NSPECIES+NMASS_SCALARS>0
    if (flux(HY_MASS @M hy_i123) > 0.) then
       flux(HY_NUM_FLUX+1:NFLUXES @M hy_i123) = XL(HY_NUM_VARS+1:NRECON @M hy_m123)*flux(HY_MASS @M hy_i123)
     else
       flux(HY_NUM_FLUX+1:NFLUXES @M hy_i123) = XR(HY_NUM_VARS+1:NRECON @M hy_i123)*flux(HY_MASS @M hy_i123)
     end if
 #endif


[hy_setHSE]
definition=
 #ifdef GRAVITY
   dx = hy_del(dir)
 #ifdef GPOT_VAR
   accelM = hy_grv(i1  @M hy_i23)   - hy_grv(i1-1  @M hy_i23)
   accelP = hy_grv(i1+1  @M hy_i23) - hy_grv(i1  @M hy_i23)
 #else
   accelM = 0.5*(hy_grv(i1-1  @M hy_i23) + hy_grv(i1  @M hy_i23)  )*dx
   accelP = 0.5*(hy_grv(i1  @M hy_i23)   + hy_grv(i1+1  @M hy_i23))*dx
 #endif
   hy_snake(HY_PRES,i1-1 @M hy_i23) = hy_snake(HY_PRES,i1-1 @M hy_i23) - &
         0.5*(hy_snake(HY_DENS ,i1-1 @M hy_i23)+hy_snake(HY_DENS,i1 @M hy_i23)) * accelM
   hy_snake(HY_PRES,i1+1 @M hy_i23) = hy_snake(HY_PRES, i1+1 @M hy_i23) + &
         0.5*(hy_snake(HY_DENS,i1 @M hy_i23)+hy_snake(HY_DENS,i1+1 @M hy_i23)) * accelP
 #endif /* GRAVITY */

[hy_resetHSE]
definition=
 #ifdef GRAVITY
   dx = hy_del(dir)
 #ifdef GPOT_VAR
   accelM = hy_grv(i1  @M hy_i23)   - hy_grv(i1-1  @M hy_i23)
   accelP = hy_grv(i1+1  @M hy_i23) - hy_grv(i1  @M hy_i23)
 #else
   accelM = 0.5*(hy_grv(i1-1  @M hy_i23) + hy_grv(i1  @M hy_i23)  )*dx
   accelP = 0.5*(hy_grv(i1  @M hy_i23)   + hy_grv(i1+1  @M hy_i23))*dx
 #endif
   hy_snake(HY_PRES,i1-1 @M hy_i23) = hy_snake(HY_PRES ,i1-1 @M hy_i23) + &
         0.5*(hy_snake(HY_DENS ,i1-1 @M hy_i23)+hy_snake(HY_DENS, i1 @M hy_i23)) * accelM
   hy_snake(HY_PRES,i1+1 @M hy_i23) = hy_snake(HY_PRES ,i1+1 @M hy_i23) - &
         0.5*(hy_snake(HY_DENS,i1 @M hy_i23)+hy_snake(HY_DENS ,i1+1 @M hy_i23)) * accelP
 #endif /* GRAVITY */


[hy_avisc]
definition =
    cvisc = hy_cvisc*max(-(hy_snake(HY_VELX+dir-1,i1@M hy_i23) - hy_snake(HY_VELX+dir-1,i1-1@M hy_i23)),0.)

   ! Construct minus and plus TOTAL energy densities
   VenerLo = hy_snake(HY_DENS,i1-1@M hy_i23)*0.5*(dot_product(hy_snake(HY_VELX:HY_VELZ,i1-1@M hy_i23),hy_snake(HY_VELX:HY_VELZ,i1-1@M hy_i23)))&
            + hy_snake(HY_RHOE,i1-1@M hy_i23)
   VenerHi = hy_snake(HY_DENS,i1@M hy_i23)*0.5*(dot_product(hy_snake(HY_VELX:HY_VELZ,i1@M hy_i23),hy_snake(HY_VELX:HY_VELZ,i1@M hy_i23)))&
            + hy_snake(HY_RHOE,i1@M hy_i23)

   hy_flux(HY_MASS:HY_ENER@M hy_i123) = &
         hy_flux(HY_MASS:HY_ENER@M hy_i123) &
         +cvisc*(/hy_snake(HY_DENS,i1-1@M hy_i23)                 - hy_snake(HY_DENS,i1@M hy_i23)&
         ,        hy_snake(HY_DENS,i1-1@M hy_i23)*hy_snake(HY_VELX,i1-1@M hy_i23) - hy_snake(HY_DENS,i1@M hy_i23)*hy_snake(HY_VELX,i1@M hy_i23)&
         ,        hy_snake(HY_DENS,i1-1@M hy_i23)*hy_snake(HY_VELY,i1-1@M hy_i23) - hy_snake(HY_DENS,i1@M hy_i23)*hy_snake(HY_VELY,i1@M hy_i23)&
         ,        hy_snake(HY_DENS,i1-1@M hy_i23)*hy_snake(HY_VELZ,i1-1@M hy_i23) - hy_snake(HY_DENS,i1@M hy_i23)*hy_snake(HY_VELZ,i1@M hy_i23)&
         ,        VenerLo                         - VenerHi/)
 #ifdef SPARK_GLM
   hy_flux(HY_FMGX:HY_FPSI@M hy_i123) = &
         hy_flux(HY_FMGX:HY_FPSI@M hy_i123) &
         +cvisc*(/hy_snake(HY_MAGX,i1-1@M hy_i23)                 - hy_snake(HY_MAGX,i1@M hy_i23)&
         ,        hy_snake(HY_MAGY,i1-1@M hy_i23)                 - hy_snake(HY_MAGY,i1@M hy_i23)&
         ,        hy_snake(HY_MAGZ,i1-1@M hy_i23)                 - hy_snake(HY_MAGZ,i1@M hy_i23)&
         ,        hy_snake(HY_PSIB,i1-1@M hy_i23)                 - hy_snake(HY_PSIB,i1@M hy_i23)/)
 #endif

