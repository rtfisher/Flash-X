!!****i** source/physics/Hydro/HydroMain/Spark/Hydro_funcs
!! NOTICE
!!  Copyright 2022 UChicago Argonne, LLC and contributors
!!
!!  Licensed under the Apache License, Version 2.0 (the "License");
!!  you may not use this file except in compliance with the License.
!!
!!  Unless required by applicable law or agreed to in writing, software
!!  distributed under the License is distributed on an "AS IS" BASIS,
!!  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!  See the License for the specific language governing permissions and
!!  limitations under the License.
!!
!! NAME
!!  Hydro_funcs
!!
!! DESCRIPTION
!!
!!  Holds functions frequently accessed by Hydro.F90 for Spark hydrodynamic solver.
!! 
!!***
!!Reorder directive used by FLASH with --index-reorder flag at setup
!!Reorder(4): hy_starState,Uin, U, hy_fl[xyz], hy_fluxBuf[XYZ]

#include "Simulation.h"
#include "constants.h"
#include "Spark.h"
#include "Eos.h"
#define NRECON HY_NUM_VARS+NSPECIES+NMASS_SCALARS

subroutine allocate_scr(blkLimits,blkLimitsGC)
  
  use Hydro_data, ONLY : hy_starState,  hy_fluxCorrect, hy_grav, hy_flx, hy_fly, hy_flz,&
       hy_tiny,hy_hybridRiemann,hy_C_hyp, &
       hy_smalldens, hy_smallE, hy_smallpres, hy_smallX, hy_cvisc, hy_del,hy_geometry, &
       hy_alphaGLM,hy_Vc,scratch_allocated
  use Hydro_offload_data, ONLY : hydro_GPU_scratch, hy_uPlus, hy_uMinus,&
       hy_shck, hy_snake, hy_flux, hy_flat, hy_grv,hy_flat3d,hy_tmpState
  implicit none
  integer,dimension(LOW:HIGH,MDIM),intent(IN) :: blkLimits, blkLimitsGC
  
  integer :: max_edge, max_edge_y, max_edge_z
  
  max_edge = max(blkLimitsGC(HIGH,IAXIS)-blkLimitsGC(LOW,IAXIS) + 2,blkLimitsGC(HIGH,JAXIS)-blkLimitsGC(LOW,JAXIS) + 2, &
       blkLimitsGC(HIGH,KAXIS)-blkLimitsGC(LOW,KAXIS) + 2)
  max_edge_y = 1
  max_edge_z = 1
#if NDIM==2
  max_edge_y = max_edge
#elif NDIM==3
  max_edge_y = max_edge
  max_edge_z = max_edge
#endif
  ! print *, "max edge", max_edge
  !Construct arrays to hold fluxes used for solution update
  
  if (.NOT. allocated(hy_flx)) then
     allocate(hy_flx(NFLUXES,@M bounds_3d_plus(blkLimitsGC,1,0,0)))
     hy_flx = 0.
  endif
  
  if (.NOT. allocated(hy_fly)) then
     allocate(hy_fly(NFLUXES,@M bounds_3d_plus(blkLimitsGC,0,1,0)))
     hy_fly = 0.
  endif
  if (.NOT. allocated(hy_flz)) then
     allocate(hy_flz(NFLUXES,@M bounds_3d_plus(blkLimitsGC,0,0,1)))
     hy_flz = 0.
  endif
  if (.NOT. allocated(hy_flat3d)) then
     allocate(hy_flat3d(@M bounds_3d(blkLimitsGC)))
     hy_flat3d = 0.
  endif
  if (.NOT. allocated(hy_Vc)) then
     allocate(hy_Vc(@M bounds_3d(blkLimitsGC)))
     hy_Vc =0.
  end if
  
  
  
  !Gravity 
  if (.NOT. allocated(hy_grav)) then
     allocate(hy_grav(MDIM,@M bounds_3d(blkLimitsGC)))
  endif
  
  if (.NOT. allocated(hy_starState)) then
     allocate(hy_starState(NUNK_VARS,@M bounds_3d(blkLimitsGC)))
  endif
  
  if (.NOT. allocated(hy_tmpState)) then
     allocate(hy_tmpState(NUNK_VARS,@M bounds_3d(blkLimitsGC)))
  endif

  @M hy_snake_allocate

  call allocate_fxscr(blkLimits,blkLimitsGC)
  
end subroutine allocate_scr

subroutine deallocate_scr()
  use Hydro_data, ONLY : hy_starState,  hy_grav, hy_flx, hy_fly, hy_flz,&
       hy_Vc
  
  use Hydro_offload_data, ONLY : &
       hy_flat3d,hy_tmpState

  if(allocated(hy_flx))deallocate(hy_flx)
  if(allocated(hy_fly))deallocate(hy_fly)
  if(allocated(hy_flz))deallocate(hy_flz)
  if(allocated(hy_flat3d))deallocate(hy_flat3d)
  if(allocated(hy_Vc))deallocate(hy_Vc)
  if(allocated(hy_grav))deallocate(hy_grav)
  if(allocated(hy_starState))deallocate(hy_starState)
  if(allocated(hy_tmpState))deallocate(hy_tmpState)
  call deallocate_fxscr()
end subroutine deallocate_scr

subroutine allocate_fxscr(blkLimits,blkLimitsGC)
  use Hydro_data, ONLY : hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
       hy_eosData, hy_mfrac, hy_fluxCorrect
  integer,dimension(LOW:HIGH,MDIM),intent(IN) :: blkLimits, blkLimitsGC
  integer :: max_edge

  max_edge = max(blkLimitsGC(HIGH,IAXIS)-blkLimitsGC(LOW,IAXIS) + 2,blkLimitsGC(HIGH,JAXIS)-blkLimitsGC(LOW,JAXIS) + 2, &
       blkLimitsGC(HIGH,KAXIS)-blkLimitsGC(LOW,KAXIS) + 2)

  !Allocate size of flux buffers used for flux correction
  if (hy_fluxCorrect) then
     !allocate buffers here
     if (.NOT. allocated(hy_fluxBufX)) then 
        allocate(hy_fluxBufX(NFLUXES,@M bounds_3d_plus(blkLimits,1,0,0)))
        hy_fluxBufX = 0.
     endif
     
     if (.NOT. allocated(hy_fluxBufY)) then 
        allocate(hy_fluxBufY(NFLUXES,@M bounds_3d_plus(blkLimits,0,1,0)))
        hy_fluxBufY = 0.
     endif
     
     if (.NOT. allocated(hy_fluxBufZ)) then 
        allocate(hy_fluxBufZ(NFLUXES,@M bounds_3d_plus(blkLimits,0,0,1)))
        hy_fluxBufZ = 0.
     endif
  endif
  !Set up one block's worth of local gravity.  Allocation allows for compatibility with Paramesh4 and AMRex

  if (.NOT. allocated(hy_eosData)) then
     allocate(hy_eosData(EOS_NUM*max_edge))
     hy_eosData = 0.
  endif
  
  if (.NOT. allocated(hy_mfrac)) then
     allocate(hy_mfrac(NSPECIES*max_edge))
     hy_mfrac = 0.
  endif
end subroutine allocate_fxscr


subroutine deallocate_fxscr()
  use Hydro_data, ONLY : hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, &
       hy_eosData, hy_mfrac, hy_fluxCorrect

  !Allocate size of flux buffers used for flux correction
  if (hy_fluxCorrect) then
     !allocate buffers here
     if(allocated(hy_fluxBufX))deallocate(hy_fluxBufX)
     if(allocated(hy_fluxBufY))deallocate(hy_fluxBufY)
     if(allocated(hy_fluxBufZ))deallocate(hy_fluxBufZ)
  end if

  if(allocated(hy_mfrac))deallocate(hy_mfrac)
  if(allocated(hy_eosData))deallocate(hy_eosData)
end subroutine deallocate_fxscr

subroutine addFluxes(lev,blkLimits,weight,addFlux)
  !Store weighted fluxes, summed over RK stages, in temporary flux buffers.
  use Hydro_data, ONLY : hy_flx, hy_fly, hy_flz, hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ 
  
  implicit none
  
  integer,intent(IN)::lev
  integer, dimension(LOW:HIGH,MDIM),intent(IN) :: blkLimits
  real, intent(IN) :: weight
  logical, intent(IN) :: addFlux
  
  
  if (addFlux) then
     hy_fluxBufX = hy_fluxBufX+weight*hy_flx(:,@M bounds_3d_plus(blkLimits,1,0,0)) 
     if (NDIM > 1) &   
          hy_fluxBufY = hy_fluxBufY+weight*hy_fly(:, @M bounds_3d_plus(blkLimits,0,1,0))
     if (NDIM > 2) &
          hy_fluxBufZ = hy_fluxBufZ+weight*hy_flz(:,@M bounds_3d_plus(blkLimits,0,0,1))
  else
     hy_fluxBufX = weight*hy_flx(:,@M bounds_3d_plus(blkLimits,1,0,0)) 
     if (NDIM > 1) &   
          hy_fluxBufY = weight*hy_fly(:, @M bounds_3d_plus(blkLimits,0,1,0))
     if (NDIM > 2) &
          hy_fluxBufZ = weight*hy_flz(:,@M bounds_3d_plus(blkLimits,0,0,1))
     
  endif
end subroutine addFluxes

!! Allocate variable size array holding local gravitational accelerations (depending on 
!! block size), fluxes, flux buffers, and save. 
!! If offloading to a device, send data and allocate on device only.
subroutine saveState(Uin,blkLimits,blklimitsGC)
  use Timers_interface, ONLY : Timers_start, Timers_stop
  use Hydro_data, ONLY : hy_starState, hy_threadWithinBlock, hy_fluxCorrect, hy_grav, hy_flx, hy_fly, hy_flz,&
       hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, hy_tiny,hy_hybridRiemann,hy_C_hyp, &
       hy_smalldens, hy_smallE, hy_smallpres, hy_smallX, hy_cvisc, hy_del,hy_geometry, &
       hy_alphaGLM, scratch_allocated
  use Hydro_offload_data, ONLY : hydro_GPU_scratch, hy_uPlus, hy_uMinus,&
       hy_shck, hy_snake, hy_flux, hy_flat, hy_tmpState,hy_flat3d, hy_grv
  implicit none
  
  integer, dimension(LOW:HIGH,MDIM),intent(IN) :: blkLimits, blkLimitsGC
  real, pointer :: Uin(:,:,:,:)
  integer ::  v,i1,i2,i3
  ! call Timers_start("Allocations")
  
  ! Allocate needed space on GPU if it is not already there
  !  !$omp target enter data map(alloc:hy_flat,hy_shck,hy_snake,hy_uMinus,hy_uPlus) 
  
  
  ! update temp vars with solution data
  
  @M hy_saveState_omp
  
  @M loop_3d_alt(blkLimitsGC,i1,i2,i3)
           do v=1,NUNK_VARS
              hy_starState(v,i1,i2,i3) = Uin(v,i1,i2,i3)
              hy_tmpState(v,i1,i2,i3) = Uin(v,i1,i2,i3)
           enddo
  @M loop_end_3d
end subroutine saveState


subroutine updateState(Uin,blkLimits,blkLimitsGC)
  use Hydro_data, ONLY : hy_starState, hy_threadWithinBlock, hy_grav, hy_flx, hy_fly, hy_flz,&
                         hy_fluxBufX, hy_fluxBufY, hy_fluxBufZ, hy_fluxCorrect, &
                         hy_smalldens, hy_smallE, hy_smallpres, &
                         hy_smallX, hy_cvisc, hy_del
  use Hydro_offload_data, ONLY : hydro_GPU_scratch, hy_uPlus, hy_uMinus,&
       hy_shck, hy_snake, hy_flux, hy_flat, hy_tmpState,hy_flat3d
  
  implicit none
  real,dimension(:,:,:,:),pointer :: Uin
  integer, dimension(LOW:HIGH,MDIM),intent(IN) :: blkLimits, blkLimitsGC
  @M hy_update_omp

#ifndef FIXEDBLOCKSIZE
!!$  if (hy_fluxCorrect) then
!!$    deallocate(hy_fluxBufX);deallocate(hy_fluxBufY);deallocate(hy_fluxBufZ)
!!$  endif
#endif
 

  !$omp parallel if(hy_threadWithinBlock) &
  !$omp default(none) &
  !$omp shared(Uin,hy_starState,blkLimits,blkLimitsGC)
  !$omp workshare
#ifdef GPOT_VAR
  ! First reset GPOT_VAR.
  hy_starState(GPOT_VAR,@M bounds_3d(blkLimits)) = &
       Uin(GPOT_VAR,@M bounds_3d(blkLimits))
#endif
  Uin(:,@M bounds_3d(blkLimits)) = &
       hy_starState(:,@M bounds_3d(blkLimits))
  
  !$omp end workshare
  !$omp end parallel
  @M hy_update_omp2

!!$  deallocate(hy_starState)
end subroutine updateState

!! Set loop limits.  We include ngcell layers of guard zones
subroutine setLims(ngcell,blkLimits,limits)
  implicit none
  integer, intent(IN):: ngcell
  integer, intent(IN), dimension(LOW:HIGH,MDIM) :: blkLimits
  integer, intent(OUT), dimension(LOW:HIGH,MDIM) :: limits
  
  integer i
  
  
  limits = blkLimits
  do i=1,NDIM
     limits(LOW ,i) = blkLimits(LOW ,i) - ngcell
     limits(HIGH,i) = blkLimits(HIGH,i) + ngcell
  end do
end subroutine setLims

subroutine shockDetect(Uin,limits,blkLimitsGC)

  use Hydro_data,        only : hy_geometry, hy_tiny, hy_Vc

  implicit none


  !! ---- Argument List ----------------------------------
  real, dimension(:,:,:,:), pointer   :: Uin
  integer, intent(IN) :: limits(LOW:HIGH,MDIM)
  integer, intent(IN) :: blkLimitsGC(LOW:HIGH,MDIM)
  !! -----------------------------------------------------

  integer :: i,j,k
  logical :: SW1, SW2


  real :: divv,gradPx,gradPy,gradPz
  real :: minP,minC,beta,delta
  real :: localCfl,cflMax
  
  !necessary for argument for %getDataPtr()

#ifndef SHOK_VAR
  return
#endif

  ! Two parameters that can be adjusted to detect shocks
  ! with different strengths:
  ! (a) The lower the values the weaker shocks detected
  !     (lower the values to detect more shock regions)
  ! (b) The larger the values the stronger shocks detected
  !     (increase the values to detect less shock regions)
  beta = 0.5 !0.5 !10. ! gradP
  delta= 0.1  !0.1 !2. ! divV
!!$  beta  = 0.1 !0.1
!!$  delta = 0.01



  Uin(SHOK_VAR,:,:,:) = 0.
  

  !! Allocate a temporary cell-centered array for sound speed


  !! Compute sound speed
  @M loop_3d(blkLimitsGC)
           hy_Vc(i,j,k) = sqrt(Uin(GAMC_VAR,i,j,k)*Uin(PRES_VAR,i,j,k)&
                /max(Uin(DENS_VAR,i,j,k),hy_tiny))
  @M loop_end_3d

  @M loop_3d(limits)

           ! initialize switch values
           SW1 = .false.
           SW2 = .false.

#if NDIM==1
           minP = minval(Uin(PRES_VAR,i-1:i+1,j,k))
           minC = minval(hy_Vc(i-1:i+1,j,k))
#endif
#if NDIM==2
           minP = minval(Uin(PRES_VAR,i-1:i+1,j-1:j+1,k))
           minC = minval(hy_Vc(i-1:i+1,j-1:j+1,k))
#endif
#if NDIM==3
           minP = minval(Uin(PRES_VAR,i-1:i+1,j-1:j+1,k-1:k+1))
           minC = minval(hy_Vc(i-1:i+1,j-1:j+1,k-1:k+1))
#endif
           !! We do not need to include non-Cartesian geom factors here.
           !! Undivided divV
           divv =        Uin(VELX_VAR,i+1,j,  k  ) - Uin(VELX_VAR,i-1,j,  k  )
#if NDIM > 1
           divv = divv + Uin(VELY_VAR,i,  j+1,k  ) - Uin(VELY_VAR,i,  j-1,k  )
#if NDIM == 3
           divv = divv + Uin(VELZ_VAR,i,  j,  k+1) - Uin(VELZ_VAR,i,  j,  k-1)
#endif
#endif
           divv = 0.5*divv

           !! Undivided grad pres
           gradPx = 0.5*(Uin(PRES_VAR,i+1,j,  k  ) - Uin(PRES_VAR,i-1,j,  k  ))
           gradPy = 0.
           gradPz = 0.
#if NDIM > 1
           gradPy = 0.5*(Uin(PRES_VAR,i,  j+1,k  ) - Uin(PRES_VAR,i,  j-1,k  ))
#if NDIM == 3
           gradPz = 0.5*(Uin(PRES_VAR,i,  j,  k+1) - Uin(PRES_VAR,i,  j,  k-1))
#endif
#endif
           if ( abs(gradPx)+abs(gradPy)+abs(gradPz) .ge. beta*minP ) then
              SW1 = .true.
           endif
           if (-delta*minC .ge. divv) then
              SW2 = .true.
           endif
           if (SW1 .and. SW2) then
              ! Set SHOCK_VAR to 1.0 if a shock is detected.
              ! One use is for a local hybrid method in the Hydro unit which
              ! applies (a diffusive) HLL solver when SHOK_VAR = 1.
              Uin(SHOK_VAR,i,j,k) = 1.
           endif !endif (SW1 .and. SW2) then
    @M loop_end_3d
    

end subroutine shockDetect

!!Calculate divergence of the magnetic field.
subroutine calcDivB(Uin,hy_del,blkLimits)
  implicit none

  real, dimension(:,:,:,:), pointer   :: Uin
  real, dimension(MDIM),intent(IN) :: hy_del
  integer, dimension(LOW:HIGH,MDIM),intent(IN) :: blkLimits


  real :: divB


#ifdef SPARK_GLM

  @M loop_3d(blkLimits)
           divB = 0.0
#if NDIM>1
           divB = (Uin(MAGX_VAR,i+1,j,k) - Uin(MAGX_VAR,i-1,j,k))&
                *0.5/hy_del(IAXIS)
           divB = divB + (Uin(MAGY_VAR,i,j+1,k) - Uin(MAGY_VAR,i,j-1,k))&
                *0.5/hy_del(JAXIS)
#if NDIM==3
           divB = divB + (Uin(MAGZ_VAR,i,j,k+1) - Uin(MAGZ_VAR,i,j,k-1))&
                *0.5/hy_del(KAXIS)
#endif
#endif
           Uin(DIVB_VAR,i,j,k) = divB
   @M loop_end_3d
#endif
end subroutine calcDivB

