[hy_name]
definition=
   Hydro

[hy_funcs_name]
definition=
   Hydro_funcs

[hy_riemann_name]
definition=
   riemann

[hy_recon_name]
definition=
   reconstruct

[hy_rk_ff_name]
definition=
   hy_rk_getFaceFlux
   

[hy_rk_ff_args]
definition=
   blklimits,blkLimitsGC,hy_del, limits

[hy_rk_ff_use]
definition=
    use Hydro_inhost_data, ONLY : hy_pgrv,hy_pshck,hy_pflat,hy_flat3d,hy_pen,hy_uPlus,hy_uMinus,hy_flux

[hy_grav_name]
definition=
   hy_rk_getGravAccel

[hy_grav_call_args]
definition =
  hy_del,limits,blkLimitsGC,level


[hy_update_name]
definition =
   hy_rk_updateSoln

[hy_update_call_args]
definition =
    Uin,blkLimits,blklimitsGC,level,hy_del, dt, dtOld, limits, coeffs

[hy_geofacs]
definition =
   call geoFacs(i,j,k,facM,facP,Sgeo,Ustar,Vstar,dx)

[hy_check_device]
definition =

[hy_renormAbundance]
definition =
           nullify(Utemp)
           Utemp => hy_starState
           call Grid_renormAbundance(tileDesc,blkLimitsGC,Utemp)
           nullify(Utemp)

[hy_rk_ff_setpointers]
definition =

[hy_rk_ff_resetpointers]
definition =


[hy_snake_allocate]
definition =


[hy_rk_pointers]
definition=
  real, dimension(MDIM),intent(IN) :: hy_del
  real, pointer ::hy_snake(:,:), hy_grv(:),hy_shck(:),hy_flat(:)!?,phy_flat3d(:,:,:)
  real, dimension(NRECON), target :: leftState, rightState
  integer, dimension(LOW:HIGH,MDIM) :: hy_dlim
  real :: speed


[hy_inShock]
definition=
    inShock = any(hy_shck(i1-1:i1) /= 0.0)

[hy_setLoop]
definition = 
  !!Set loop dimensions based on the direction of the pencil set
    select case(dir)
    case (IAXIS)
       hy_dlim(:,:) = limits(:,:)
    case (JAXIS)
       hy_dlim(:,1) = limits(:,JAXIS)
       hy_dlim(:,2) = limits(:,IAXIS)
       hy_dlim(:,3) = limits(:,KAXIS)
    case (KAXIS)
       hy_dlim(:,1) = limits(:,KAXIS)
       hy_dlim(:,2) = limits(:,IAXIS)
       hy_dlim(:,3) = limits(:,JAXIS)
    end select


[hy_setLims_FF]
definition =
     select case(dir)
     case (IAXIS)
        pLo = xLoGC;pHi = xHiGC
     case (JAXIS)
         pLo = yLoGC;pHi = yHiGC
     case (KAXIS)
         pLo = zLoGC;pHi = zHiGC
     end select
     j=i2
     k=i3
     !pointers for purpose of reindexing
     hy_shck(pLo:pHi) => hy_pshck
     hy_grv(pLo:pHi) => hy_pgrv
     hy_flat(pLo:pHi) => hy_pflat
     hy_snake(1:NRECON,pLo:pHi) => hy_pen

[hy_saveFluxes]
definition =
    select case(dir)
    case(IAXIS)
     hy_flx(:,i1,i2,i3) = hy_flux(:)
    case (JAXIS)
     hy_fly(:,i2,i1,i3) = hy_flux(:)
    case (KAXIS)
     hy_flz(:,i2,i3,i1) = hy_flux(:)
    end select

[hy_nullify]
definition =
    nullify(hy_shck)
    nullify(hy_grv)
    nullify(hy_flat)


[hy_snake_loop]
definition =
  do i = pLo,pHi


[hy_snake_loop_end]
definition =
   end do

[hy_dim_loop]
definition = 
  do i3 = hy_dlim(LOW,3), hy_dlim(HIGH,3)
        do i2 = hy_dlim(LOW,2), hy_dlim(HIGH,2)

[hy_dim_loop_end]
definition =
         end do
     end do


[hy_rk_loop]
definition =

[hy_rk_loop_end]
definition = 


[hy_rk_step1]
definition =
         !call setHSE(hy_snake,hy_grv,hy_dlim(LOW,1)-1,hy_del(dir))
           i1 = hy_dlim(LOW,1) - 1 
            @M hy_recon_call
           !call resetHSE(hy_snake,hy_grv,hy_dlim(LOW,1)-1,hy_del(dir))
           do i1 = hy_dlim(LOW,1), hy_dlim(HIGH,1)+1
              ! cycle left-right state vectors
              leftState = hy_uPlus
              ! Now do the reconstruction for ALL variables in one call
              !call setHSE(hy_snake,hy_grv,i1,hy_del(dir))
              @M hy_recon_call
               !call resetHSE(hy_snake,hy_grv,i1,hy_del(dir))
               rightState = hy_uMinus
               ! Make sure that reconstruction has not introduced unphysical states
               @M hy_ensurePhysicalState(leftState)
               @M hy_ensurePhysicalState(rightState)


[hy_isn]
type=inline
definition =
  i

[hy_rk_1]
definition =
     i1 = hy_dlim(LOW,1) - 1 
      @M hy_recon_call
      !call resetHSE(hy_snake,hy_grv,hy_dlim(LOW,1)-1,hy_del(dir))
      do i1 = hy_dlim(LOW,1), hy_dlim(HIGH,1)+1
      !call setHSE(hy_snake,hy_grv,hy_dlim(LOW,1)-1,hy_del(dir))
             ! cycle left-right state vectors
      leftState = hy_uPlus

[hy_rk_2]
definition =
    rightState = hy_uMinus


[hy_rk_3]
definition=
     end do  ! i

[hy_ix123]
definition =


[hy_i123]
definition =

[hy_123]
definition =


[hy_m123]
definition =


[hy_p123]
definition =


[hy_ix12]
definition =


[hy_i23]
type = inline
definition =


[hy_recon_call]
definition=
  call @M hy_recon_name(hy_uPlus, hy_uMinus, &
                hy_pen, hy_flat(i1), pLo, pHi, i1)

[hy_recon_loop]
definition =
  do v = 1,NRECON


[hy_recon_loop_end]
definition =
   end do

[hy_recon_use]
definition =

[hy_recon_call_args]
type = inline
definition = 
    hy_uPlus, hy_uMinus, hy_snake, hy_flat, pLo, pHi, i1


[hy_recon_declare]
definition =
  integer, intent(IN) :: i1, pLo, pHi
  real, intent(IN) :: hy_snake(NRECON,pLo:pHi), hy_flat
  real, dimension(NRECON), intent(OUT) :: hy_uPlus, hy_uMinus
  integer :: v

[hy_riemann_call]
type = inline
definition =
  call @M hy_riemann_name(dir,leftState(1:HY_NUM_VARS),rightState(1:HY_NUM_VARS),&
               inShock,hy_flux(1:HY_NUM_FLUX),speed,ierr)

[hy_riemann_call_args]
definition =
  dir,VL,VR,inShock,Fstar,speed,ierr

[hy_riemann_use]
definition =

[hy_riemann_assign]
definition =


[hy_riemann_declare]
definition =
  !! Arguments type declaration -----------
  integer, intent(IN) :: dir
  real, dimension(HY_NUM_VARS), intent(IN)  :: VL, VR
  logical, intent(IN) :: inShock
  real, dimension(HY_NUM_FLUX),    intent(OUT) :: Fstar
  real,    intent(OUT) :: speed
  integer, intent(OUT) :: ierr
  !! --------------------------------------

  real :: SL,SR,cfL,cfR,aL2,aR2,velNL,velNR
  real :: dStarL,dStarR,totalPresL,totalPresR
  real :: BxStar,ByStar,BzStar,Bn_hll,pStar,qStar
  real :: denomL,denomR,numerL,numerR
  real, dimension(HY_NUM_FLUX) :: UL,UR,Uhll,UCstarR,UCstarL
  real, dimension(HY_NUM_FLUX) :: FL,FR
  real :: magBL2,magBR2,magNL,magNR
  real :: Bn_glm, Psi_glm


[hy_tmp_ind]
definition=
   lo(:) = blkLimits(LOW,:)
   hi(:) = blkLimits(HIGH,:)
   loGC(:) = blkLimitsGC(LOW,:)
   hiGC(:) = blkLimitsGC(HIGH,:)
   !convenience indices
   xLoGC = loGC(IAXIS); xHiGC = hiGC(IAXIS)
   yLoGC = loGC(JAXIS); yHiGC = hiGC(JAXIS)
   zLoGC = loGC(KAXIS); zHiGC = hiGC(KAXIS)
           

[hy_setPencil]
definition=
     allocate(hy_flat3d(xLoGC:xHiGC,yLoGC:yHiGC,zLoGC:zHiGC)) 
     !set pencil indices based on dimension with largest spread
     pLo = blkLimitsGC(LOW,maxloc(blkLimitsGC(HIGH,1:MDIM)-blkLimitsGC(LOW,1:MDIM),1))
     pHi = blkLimitsGC(HIGH,maxloc(blkLimitsGC(HIGH,1:MDIM)-blkLimitsGC(LOW,1:MDIM),1))
     allocate(hy_pen(NRECON,pLo:pHi))
     allocate(hy_pgrv(pLo:pHi))
     allocate(hy_pshck(pLo:pHi))
     allocate(hy_pflat(pLo:pHi))

[hy_releasePencil]
definition=
   deallocate(hy_pen)
   deallocate(hy_pgrv)
   deallocate(hy_pshck)
   deallocate(hy_pflat)
   deallocate(hy_flat3d)




[hy_rk_ff_comp1]
definition =
  !$omp parallel if(hy_threadWithinBlock .AND. NDIM > 1) &
  !$omp default(none) &
  !$omp private(i1,i2,i3,n,j,k,hy_grv,hy_shck,hy_flat,inShock,hy_flux,ierr,speed,&
  !$omp         leftState,rightState,hy_uPlus,hy_uMinus,hy_snake,hy_pen,dir,hy_dlim,&
  !$omp         hy_pshck, hy_pgrv,hy_pflat,cvisc,venerlo,venerhi,pLo,pHi,spc,spcSumInv)&
  !$omp shared(hy_starState,hy_flx,hy_fly,hy_flz,xLoGC,yLoGC,zLoGC,&
  !$omp        xHiGC,yHiGC,zHiGC,&
  !$omp        hy_smalldens,hy_smallpres,hy_del,hy_flat3d,limits,hy_cvisc,hy_smallx)


[hy_rk_ff_comp2]
definition =
   !$omp do schedule(guided) collapse(2)

[hy_rk_ff_comp3]
definition =
   !$omp end do

[hy_rk_ff_comp4]
definition =
  !$omp end parallel


[hy_rk_ff_aomp1]
definition =


[hy_rk_ff_aomp2]
definition =



[hy_rk_ff_aomp3]
definition =


[hy_rk_ff_aomp4]
definition =



[hy_rk_ff_aomp5]
definition =



[hy_rk_ff_aomp6]
definition =



[hy_rk_ff_aomp7]
definition =


[hy_rk_ff_aomp8]
definition =


[hy_rk_ff_aomp9]
definition =

[hy_rk_ff_aomp10]
definition =


[hy_rk_ff_aomp11]
definition =


[hy_update_omp1]
definition =
    !$omp parallel do &
   !$omp default(none) &
  !$omp private(i,j,k)&
  !$omp shared(dt,limits,dtOld,coeffs,dx,dy,dz,dhdt) &
 !$omp schedule(guided) collapse(3)

[hy_grv_omp1]
definition = 


[hy_grv_omp2]
definition = 

[hy_grv_omp3]
definition = 

[hy_grv_omp4]
definition = 

[hy_saveState_omp]
definition =
  !$omp parallel do collapse(4) if(hy_threadWithinBlock) &
  !$omp default(none) &
  !$omp shared(Uin,hy_starState,blkLimits,blkLimitsGC,hy_tmpState)


[hy_update_omp]
definition =

[hy_update_omp2]
definition =











