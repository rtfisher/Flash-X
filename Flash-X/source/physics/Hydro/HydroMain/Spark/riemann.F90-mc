!!****if* source/physics/Hydro/HydroMain/Spark/riemann
!! NOTICE
!!  Copyright 2022 UChicago Argonne, LLC and contributors
!!
!!  Licensed under the Apache License, Version 2.0 (the "License");
!!  you may not use this file except in compliance with the License.
!!
!!  Unless required by applicable law or agreed to in writing, software
!!  distributed under the License is distributed on an "AS IS" BASIS,
!!  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!!  See the License for the specific language governing permissions and
!!  limitations under the License.
!!
!!  For this function the name and argument lists depend upon the variants used.
!!
!! DESCRIPTION
!!
!!   This routine computes high-order Godunov fluxes based on the left and right Riemann states.
!!
!!   The HLLC Riemann fan:
!!
!!            SL      SM=qStar    SR
!!             \        |        /
!!              \       |       /
!!               \  UL* | UR*  /
!!                \     |     /
!!                 \    |    /
!!                  \   |   /
!!           UL      \  |  /       UR
!!                    \ | /
!!                     \|/
!!   --------------------------------------
!!
!! REFERENCES
!!
!!  * S. Li, JCP, 203:344-357, 2005
!!  * Toro, Riemann Solvers and Numerical Methods for Fluid Dynamics, Springer, 1997
!!
!!***
!!! A note: the speed dummy var seems to be unused. Might be deleted?

subroutine @M hy_riemann_name (@M hy_riemann_call_args)

  use Driver_interface, ONLY : Driver_abort
  use Hydro_data,       ONLY : hy_tiny, hy_hybridRiemann, hy_C_hyp
  @M hy_riemann_use
  implicit none

#include "constants.h"
#include "Simulation.h"
#include "Spark.h"

  !! Arguments type declaration -----------
  @M hy_riemann_declare
  ! Check for shocks in the zones involved in flux calculation
 
  @M hy_riemann_assign
  
  ! Set no error to begin with
  ierr = 0

  ! Normal velocity
  velNL = VL(HY_VELX+dir-1)
  velNR = VR(HY_VELX+dir-1)

  ! Set sound speed
  aL2   = VL(HY_GAMC)*VL(HY_PRES)/VL(HY_DENS)
  aR2   = VR(HY_GAMC)*VR(HY_PRES)/VR(HY_DENS)

  ! Set zero magnetic quantities by default for hydro
  magNL = 0.
  magNR = 0.
#ifdef SPARK_GLM /* compute additional MHD waves */
  ! Reset the left and right states for the GLM evolution equations
  ! This yields the exact solution for the fluxes of the 2x2 lienar GLM system
  ! See Mignone & Tzeferacos 2010, sec. 3.2
  Bn_glm  = 0.5*(VL(HY_MAGX+dir-1)+VR(HY_MAGX+dir-1)) - 0.5/hy_C_hyp*(VR(HY_PSIB) - VL(HY_PSIB))
  Psi_glm = 0.5*(VL(HY_PSIB)+VR(HY_PSIB)) - 0.5*hy_C_hyp*(VR(HY_MAGX+dir-1)-VL(HY_MAGX+dir-1))
  magNL = VL(HY_MAGX+dir-1)
  magNR = VR(HY_MAGX+dir-1)
  magBL2= dot_product(VL(HY_MAGX:HY_MAGZ),VL(HY_MAGX:HY_MAGZ))/VL(HY_DENS)
  magBR2= dot_product(VR(HY_MAGX:HY_MAGZ),VR(HY_MAGX:HY_MAGZ))/VR(HY_DENS)
#endif

  ! Check unphysical negativity
  if ((VL(HY_DENS) < hy_tiny .and. VL(HY_DENS) > 0.) .or. &
       (VR(HY_DENS) < hy_tiny .and. VR(HY_DENS) > 0.) .or. &
       (VL(HY_PRES) < hy_tiny .and. VL(HY_PRES) > 0.) .or. &
       (VR(HY_PRES) < hy_tiny .and. VR(HY_PRES) > 0.)) then
     ! This could be vacuum limit. We return with zero flux.
     Fstar = 0.
     return
  elseif (aL2 < 0. .or. aR2 < 0.) then
     ierr = 1
     return
  endif

  cfL = sqrt(aL2)
  cfR = sqrt(aR2)
#ifdef SPARK_GLM
  cfL = sqrt(0.5*(aL2 + magBL2 + sqrt((aL2 + magBL2 )**2 - 4.*aL2*magNL*magNL/VL(HY_DENS))))
  cfR = sqrt(0.5*(aR2 + magBR2 + sqrt((aR2 + magBR2 )**2 - 4.*aR2*magNR*magNR/VR(HY_DENS))))
#endif

  ! Get left/right going fastest wave speeds SL & SR for the left and right states
  ! by S. F. Davis, SIAM J. Sci. Stat, Comput., 9(1988) 445.
  ! Also see Miyoshi, Kusano, JCP, 208 (2005)
  SL = min(velNL - cfL, velNR - cfR)
  SR = max(velNL + cfL, velNR + cfR)

  ! Output maximum local wave speed for dt calculation
  speed = max(abs(SL),abs(SR))

  ! Total pressure
  totalPresL = VL(HY_PRES)
  totalPresR = VR(HY_PRES)
#ifdef SPARK_GLM /* for MHD */
  totalPresL = totalPresL + 0.5*dot_product(VL(HY_MAGX:HY_MAGZ),VL(HY_MAGX:HY_MAGZ))
  totalPresR = totalPresR + 0.5*dot_product(VR(HY_MAGX:HY_MAGZ),VR(HY_MAGX:HY_MAGZ))
#endif

  ! Convert primitive variables to conservative variables
  !!!*** We need to think about whether this shoud be extracted out and done on the whole block
  
  call prim2con(VL,UL)
  call prim2con(VR,UR)
  call prim2flx(dir,VL,FL)
  call prim2flx(dir,VR,FR)

  ! Get HLL states for later use
  if (SL > 0.) then
     Uhll = UL
  elseif ((SL <= 0.) .and. (SR >= 0.)) then
     Uhll = (SR*UR - SL*UL - FR + FL)/(SR - SL)
     !! Pretty sure the following is not need for pressure already in momentum
     !! fluxes (done in prim2flx). I.e., fP = 1.0
     !  Uhll(HY_DENS+dir) = Uhll(HY_DENS+dir) + &
     !       (  totalPresL - totalPresR  )/(SR - SL) * (1.0-fP)
  else
     Uhll = UR
  endif

#ifdef SPARK_GLM /* for MHD */
  ! Calculate intermediate states --------------
  Bn_hll = Uhll(HY_FMGX+dir-1) !=(SR*magNR-SL*magNL)/(SR-SL)
  BxStar = Uhll(HY_FMGX)       !BxStarL = BxStarR = BxHLL
  ByStar = Uhll(HY_FMGY)       !ByStarL = ByStarR = ByHLL
  BzStar = Uhll(HY_FMGZ)       !BzStarL = BzStarR = BzHLL
#endif

  ! (1) Normal velocity component
  ! qStarL = qStarR = qStar
  qStar=(VR(HY_DENS)*velNR*(SR-velNR) &
       - VL(HY_DENS)*velNL*(SL-velNL)  &
       + totalPresL - totalPresR       &
       - magNL**2   + magNR**2)
  ! print*, (VR(HY_DENS)*(SR-velNR) - VL(HY_DENS)*(SL-velNL))
  qStar = qStar/(VR(HY_DENS)*(SR-velNR) - VL(HY_DENS)*(SL-velNL))

  ! Convenient parameters
  numerL = SL-velNL
  denomL = SL-qStar ! I believe this could be made an inverse to save FLOPS
  numerR = SR-velNR
  denomR = SR-qStar

  ! (2) Total pressure in the star region
  ! pStarL = pStarR = pStar
  pStar = VL(HY_DENS)*numerL*(qStar-velNL)+totalPresL
#ifdef SPARK_GLM /* for MHD */
  pStar = pStar - magNL**2 + Bn_hll**2
#endif

  ! (3) Density
  dStarL = UL(HY_MASS)*numerL/denomL
  dStarR = UR(HY_MASS)*numerR/denomR

  ! (4) Conserved variables in the two-state (left & right) star regions
  UCstarL(HY_MASS)   = dStarL
  UCstarL(HY_ENER)   = UL(HY_ENER)*numerL/denomL + &
       ((pStar*qStar - totalPresL*velNL))/denomL

  UCstarR(HY_MASS)   = dStarR
  UCstarR(HY_ENER)   = UR(HY_ENER)*numerR/denomR + &
       ((pStar*qStar - totalPresR*velNR))/denomR

#ifdef SPARK_GLM /* for MHD */
  UCstarL(HY_FMGX:HY_FMGZ)= Uhll(HY_FMGX:HY_FMGZ)
  UCstarL(HY_ENER) = UCstarL(HY_ENER) &
       -(Bn_hll*dot_product(Uhll(HY_FMGX:HY_FMGZ),Uhll(HY_XMOM:HY_ZMOM))/Uhll(HY_MASS) &
       -  magNL*dot_product(VL(HY_MAGX:HY_MAGZ),  VL(HY_VELX:HY_VELZ)))/denomL

  UCstarR(HY_FMGX:HY_FMGZ)= Uhll(HY_FMGX:HY_FMGZ)
  UCstarR(HY_ENER) = UCstarR(HY_ENER) &
       -(Bn_hll*dot_product(Uhll(HY_FMGX:HY_FMGZ),Uhll(HY_XMOM:HY_ZMOM))/Uhll(HY_MASS) &
       -  magNR*dot_product(VR(HY_MAGX:HY_MAGZ),  VR(HY_VELX:HY_VELZ)))/denomR
#endif

  select case (dir)
  case (IAXIS)
     UCstarL(HY_XMOM) = dStarL*qStar
     UCstarL(HY_YMOM) = UL(HY_YMOM)*numerL/denomL
     UCstarL(HY_ZMOM) = UL(HY_ZMOM)*numerL/denomL

     UCstarR(HY_XMOM) = dStarR*qStar
     UCstarR(HY_YMOM) = UR(HY_YMOM)*numerR/denomR
     UCstarR(HY_ZMOM) = UR(HY_ZMOM)*numerR/denomR

#ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_YMOM) = UCstarL(HY_YMOM) - (BxStar*ByStar-VL(HY_MAGX)*VL(HY_MAGY))/denomL
     UCstarL(HY_ZMOM) = UCstarL(HY_ZMOM) - (BxStar*BzStar-VL(HY_MAGX)*VL(HY_MAGZ))/denomL

     UCstarR(HY_YMOM) = UCstarR(HY_YMOM) - (BxStar*ByStar-VR(HY_MAGX)*VR(HY_MAGY))/denomR
     UCstarR(HY_ZMOM) = UCstarR(HY_ZMOM) - (BxStar*BzStar-VR(HY_MAGX)*VR(HY_MAGZ))/denomR
#endif

  case (JAXIS)
     UCstarL(HY_XMOM) = UL(HY_XMOM)*numerL/denomL
     UCstarL(HY_YMOM) = dStarL*qStar
     UCstarL(HY_ZMOM) = UL(HY_ZMOM)*numerL/denomL

     UCstarR(HY_XMOM) = UR(HY_XMOM)*numerR/denomR
     UCstarR(HY_YMOM) = dStarR*qStar
     UCstarR(HY_ZMOM) = UR(HY_ZMOM)*numerR/denomR

#ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_XMOM) = UCstarL(HY_XMOM) - (ByStar*BxStar-VL(HY_MAGY)*VL(HY_MAGX))/denomL
     UCstarL(HY_ZMOM) = UCstarL(HY_ZMOM) - (ByStar*BzStar-VL(HY_MAGY)*VL(HY_MAGZ))/denomL

     UCstarR(HY_XMOM) = UCstarR(HY_XMOM) - (ByStar*BxStar-VR(HY_MAGY)*VR(HY_MAGX))/denomR
     UCstarR(HY_ZMOM) = UCstarR(HY_ZMOM) - (ByStar*BzStar-VR(HY_MAGY)*VR(HY_MAGZ))/denomR
#endif

  case (KAXIS)
     UCstarL(HY_XMOM) = UL(HY_XMOM)*numerL/denomL
     UCstarL(HY_YMOM) = UL(HY_YMOM)*numerL/denomL
     UCstarL(HY_ZMOM) = dStarL*qStar

     UCstarR(HY_XMOM) = UR(HY_XMOM)*numerR/denomR
     UCstarR(HY_YMOM) = UR(HY_YMOM)*numerR/denomR
     UCstarR(HY_ZMOM) = dStarR*qStar

#ifdef SPARK_GLM /* for MHD */
     UCstarL(HY_XMOM) = UCstarL(HY_XMOM) - (BzStar*BxStar-VL(HY_MAGZ)*VL(HY_MAGX))/denomL
     UCstarL(HY_YMOM) = UCstarL(HY_YMOM) - (BzStar*ByStar-VL(HY_MAGZ)*VL(HY_MAGY))/denomL

     UCstarR(HY_XMOM) = UCstarR(HY_XMOM) - (BzStar*BxStar-VR(HY_MAGZ)*VR(HY_MAGX))/denomR
     UCstarR(HY_YMOM) = UCstarR(HY_YMOM) - (BzStar*ByStar-VR(HY_MAGZ)*VR(HY_MAGY))/denomR
#endif
  end select


  ! End of calculating HLLC intermediate states ---------------------------

  ! (5) Finally, calculate HLLC fluxes
  if (SL >= 0.) then
     Fstar = FL
  elseif ((SL < 0.).and. (qStar >= 0.)) then
     Fstar = FL + SL*(UCstarL - UL)
  elseif ((qStar <0.) .and. (SR >= 0.)) then
     Fstar = FR + SR*(UCstarR - UR)
  else
     Fstar = FR
  endif

  !! The following are the HLLE fluxes.
  if (hy_hybridRiemann .AND. inShock) then
     if (SL > 0.) then
        Fstar = FL
     elseif (SR < 0.) then
        Fstar = FR
     else !if ((SL <= 0.) .and. (SR >= 0.)) then
        Fstar = (SR*FL - SL*FR + SR*SL*(UR - UL))/(SR - SL)
     endif
  end if

#ifdef SPARK_GLM
  ! The exact fluxes for the 2x2 GLM sub-system
  Fstar(HY_FMGX+dir-1) = Psi_glm
  Fstar(HY_FPSI) = hy_C_hyp*hy_C_hyp*Bn_glm
#endif

end Subroutine @M hy_riemann_name

